## CI

Note:
In keiner Softwareentwicklung kann heutzutage CI/CD fehlen, deswegen wollen wir auch dazu ein paar Worte verlieren.

--

```yaml [|3-7|14-18|19-23|22|24-29|30-35]
name: CI

on:
  push:
    branches: [develop]
  pull_request:
    branches: [develop]

jobs:
  test:
    name: CI Gate
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: install tools, build and test
        run: |
          .\build.ps1 -install
          .\build.ps1 -target selftests
        shell: powershell
      - name: Publish Test Results
        uses: EnricoMi/publish-unit-test-result-action/composite@v2
        if: always()
        with:
          files: |
            test/output/test-report.xml
      - uses: actions/upload-artifact@v2
        with:
          name: artifacts.zip
          retention-days: 90
          path: "build/**/artifacts.*"
          if-no-files-found: error
```

Note:
Unser Pipeline-Code ist eigentlich ziemlich kurz und soll das auch bleiben. Pipelines sollen schließlich nur als Kleber dienen, den Rest macht unser Build-System. Getriggert wird sie bei jedem PullRequest auf develop. Wir checken dann über die Pipeline unser Repo aus, installieren die Tool-Dependencies, starten uns Build System - aber dazu später mehr - werten die Testergebnisse aus zu denen auch der Build selbst zählt und laden dann Artefakte hoch. Punkt.

--

<pre><code class="fragment powershell" data-trim>
.\build.ps1 -target selftests
</code></pre>

<pre><code class="fragment powershell" data-trim>
python -m pipenv run python -m pytest test --junitxml=$pytestJunitXml
</code></pre>

<pre><code class="fragment python" data-trim>
def test_build():
    assert 0 == SplBuild(
        variant="CustA/Disco",
        build_kit="prod",
        expected_artifacts=ArtifactsCollection(
            artifacts=["spled.exe", "compile_commands.json"]
        ),
    ).execute(target="all", strict=True, archive=True)
</code></pre>

<pre><code class="fragment python" data-trim>
def test_reports():
    assert 0 == SplBuild(
        variant="CustA/Disco",
        build_kit="test",
        expected_artifacts=ArtifactsCollection(artifacts=["reports"]),
    ).execute(target="reports", strict=True, archive=True)
</code></pre>

Note:
Der eigentlich wichtigere Teil ist unser Build System. Es basiert für den eigentlichen compile und Test Build auf Cmake mit  Ninja, aber drumherum haben wir noch ein paar Powershell Scripte als Bootstrapping und Python mit Pytest für das eigetnlich Ausführen unserer CI Tests. Python widerum ruft dann in aller Regel CMake auf. Auf diese Art und Weise sahen wir uns in der lage, das Dependency Management anständig zu handlen und gleichzeitig über Python eine einfache Erweiterbarkeit von Tests zu gewährleisten, die man auch mit wenig Erfahrung des gesamten Systems bewerkstelligen kann.

--

* Mini CI-Pipeline
* etwas Python-Kleber
* CMake + C-test-Framework
